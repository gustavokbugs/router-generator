# üìã **MEGA PROMPT DETALHADO - BACKEND DIJKSTRA COM SISTEMA DE LISTA**

## üéØ **OBJETIVO GERAL:**
Implementar backend em C com algoritmo Dijkstra para calcular rotas entre pontos selecionados via LISTA (n√£o por clique no mapa).

---

## üîß **PARTE 1: BACKEND (C) - IMPLEMENTA√á√ÉO DO DIJKSTRA**

### **üìÅ ESTRUTURA DE ARQUIVOS:**

#### **1. Arquivos Existentes (N√ÉO MODIFICAR):**
- `grafo.c` / `grafo.h` - Estruturas b√°sicas do grafo
- `grafo_db.c` / `grafo_db.h` - Interface de banco de dados
- `grafo_data.c` - Dados est√°ticos dos v√©rtices e arestas (BANCO 1)

#### **2. Arquivos a MODIFICAR:**

**`grafo.h` - ADICIONAR/ALTERAR:**
```c
// ‚úÖ ADICIONAR: Struct simplificada para resultado
typedef struct {
    int* sequencia_ids;    // Array de IDs no caminho (origem ‚Üí destino)
    int num_ids;           // Quantidade de IDs no caminho
    int distancia_total;   // Dist√¢ncia total em metros
} ResultadoRota;

// ‚ùå REMOVER: Struct DadosDijkstra (n√£o √© mais necess√°ria)
// ‚ùå REMOVER: Campos ids_pontos_interesse e num_pontos_interesse
```

**`main.c` - ADICIONAR:**
```c
// ‚úÖ NOVO INCLUDE
#include "grafo_algoritmos.h"

// ‚úÖ ADICIONAR no final (antes do main()):
EXPORT ResultadoRota* calcular_rota(int id_origem, int id_destino);
EXPORT void liberar_resultado(ResultadoRota* resultado);
EXPORT int obter_numero_total_vertices();
EXPORT int obter_info_vertice(int id, char* nome_out, int nome_len, 
                             char* categoria_out, int cat_len,
                             int* x_out, int* y_out);
```

#### **3. Arquivos NOVOS (CRIAR DO ZERO):**

**`grafo_algoritmos.h` - CABE√áALHO DO DIJKSTRA:**
```c
#ifndef GRAFO_ALGORITMOS_H
#define GRAFO_ALGORITMOS_H

#include "grafo.h"
#include <limits.h>

typedef struct {
    int* sequencia_ids;
    int num_ids;
    int distancia_total;
} ResultadoRota;

#ifdef _WIN32
    #define EXPORT __declspec(dllexport)
#else
    #define EXPORT
#endif

// Fun√ß√µes principais
EXPORT ResultadoRota* calcular_rota(int id_origem, int id_destino);
EXPORT void liberar_resultado(ResultadoRota* resultado);

// Fun√ß√µes auxiliares para frontend (SISTEMA DE LISTA)
EXPORT int obter_numero_total_vertices();
EXPORT int obter_info_vertice(int id, char* nome_out, int nome_len, 
                             char* categoria_out, int cat_len,
                             int* x_out, int* y_out);

#endif
```

**`grafo_algoritmos.c` - IMPLEMENTA√á√ÉO DO DIJKSTRA:**

### **üß† FUN√á√ïES A IMPLEMENTAR:**

#### **Fun√ß√£o 1: `encontrar_menor_distancia()` (INTERNA)**
```c
static int encontrar_menor_distancia(int* distancias, int* visitados, int num_vertices)
```
**Prop√≥sito:** Encontrar v√©rtice n√£o visitado com menor dist√¢ncia.
**Fluxo:**
1. Inicializar `menor_distancia = INT_MAX`, `indice_menor = -1`
2. Percorrer todos os v√©rtices (0 at√© num_vertices-1)
3. Se v√©rtice n√£o visitado E dist√¢ncia ‚â§ menor_distancia:
   - Atualizar menor_distancia
   - Atualizar indice_menor
4. Retornar indice_menor
**‚ö†Ô∏è ALERTA:** Retorna -1 se todos os v√©rtices j√° foram visitados ou n√£o alcan√ß√°veis.

#### **Fun√ß√£o 2: `executar_dijkstra()` (INTERNA)**
```c
static int executar_dijkstra(Grafo* g, int indice_origem, int** distancias, int** anteriores)
```
**Prop√≥sito:** Executar algoritmo Dijkstra principal usando **BANCO DE DADOS 1** (coordenadas da cal√ßada).
**Fluxo:**
```
1. VALIDA√á√ÉO:
   - Verificar se grafo != NULL
   - Verificar se indice_origem est√° dentro dos limites (0 a num_vertices-1)
   - Se falhar, retornar 0 (erro)

2. ALOCA√á√ÉO DE MEM√ìRIA:
   - Alocar array distancias[num_vertices]
   - Alocar array anteriores[num_vertices] 
   - Alocar array visitados[num_vertices]
   - ‚ö†Ô∏è VERIFICAR: Se alguma aloca√ß√£o falhar ‚Üí liberar tudo e retornar 0

3. INICIALIZA√á√ÉO:
   Para i de 0 at√© num_vertices-1:
     distancias[i] = INT_MAX  (dist√¢ncia infinita)
     anteriores[i] = -1        (nenhum v√©rtice anterior)
     visitados[i] = 0          (n√£o visitado)
   distancias[indice_origem] = 0  (dist√¢ncia da origem para ela mesma)

4. ALGORITMO DIJKSTRA (Loop principal):
   Para count de 0 at√© num_vertices-1:
     a. u = encontrar_menor_distancia(distancias, visitados, num_vertices)
     b. Se u == -1 ‚Üí BREAK (n√£o h√° mais v√©rtices alcan√ß√°veis)
     c. visitados[u] = 1
     d. Para cada aresta na lista de adjac√™ncia de u:
        - v = encontrar_indice_vertice(g, aresta->destino_id)
        - Se v != -1:  // V√©rtice existe
          - nova_distancia = distancias[u] + aresta->distancia
          - Se !visitados[v] E nova_distancia < distancias[v]:
              distancias[v] = nova_distancia
              anteriores[v] = u

5. LIMPEZA E RETORNO:
   - Liberar array visitados
   - Retornar 1 (sucesso)
```

#### **Fun√ß√£o 3: `reconstruir_caminho()` (INTERNA)**
```c
static ResultadoRota* reconstruir_caminho(Grafo* g, int* distancias, int* anteriores, 
                                         int indice_origem, int indice_destino)
```
**Prop√≥sito:** Reconstruir caminho do destino at√© a origem usando array `anteriores`.
**Fluxo:**
```
1. VALIDA√á√ÉO:
   - Verificar se grafo, distancias, anteriores != NULL
   - Verificar se destino √© alcan√ß√°vel: distancias[indice_destino] != INT_MAX
   - Se falhar, retornar NULL

2. ALOCA√á√ÉO:
   - Alocar ResultadoRota* resultado
   - Alocar array tempor√°rio caminho_temp[num_vertices]
   - ‚ö†Ô∏è VERIFICAR: Se falhar aloca√ß√£o ‚Üí liberar e retornar NULL

3. RECONSTRU√á√ÉO (Destino ‚Üí Origem):
   current = indice_destino
   num_ids = 0
   Enquanto current != -1:
     caminho_temp[num_ids] = g->vertices[current].id
     num_ids++
     current = anteriores[current]
     ‚ö†Ô∏è PROTE√á√ÉO CONTRA LOOP: Se num_ids > num_vertices ‚Üí erro

4. INVERS√ÉO (Origem ‚Üí Destino):
   - Alocar resultado->sequencia_ids[num_ids]
   - Para i de 0 at√© num_ids-1:
       resultado->sequencia_ids[i] = caminho_temp[num_ids-1-i]
   - resultado->num_ids = num_ids
   - resultado->distancia_total = distancias[indice_destino]

5. LIMPEZA E RETORNO:
   - Liberar caminho_temp
   - Retornar resultado
```

#### **Fun√ß√£o 4: `calcular_rota()` (EXPORTADA - PRINCIPAL)**
```c
EXPORT ResultadoRota* calcular_rota(int id_origem, int id_destino)
```
**Prop√≥sito:** Fun√ß√£o principal chamada pelo frontend. Usa **BANCO DE DADOS 1** para c√°lculo.
**Fluxo:**
```
1. VALIDA√á√ÉO INICIAL:
   - Se id_origem == id_destino ‚Üí retornar NULL (rota trivial)
   - ‚ö†Ô∏è ALERTA: Verificar se IDs s√£o v√°lidos (‚â• 0)

2. CRIAR GRAFO (com BANCO 1):
   - Grafo* grafo = criar_grafo()
   - ‚ö†Ô∏è VERIFICAR: Se grafo == NULL ‚Üí retornar NULL

3. CARREGAR DADOS DO BANCO 1:
   - inicializar_vertices(grafo)   // Carrega coordenadas DA CAL√áADA
   - inicializar_arestas(grafo)    // Carrega conex√µes entre v√©rtices

4. CONVERTER IDs ‚Üí √çNDICES:
   - idx_origem = encontrar_indice_vertice(grafo, id_origem)
   - idx_destino = encontrar_indice_vertice(grafo, id_destino)
   - ‚ö†Ô∏è VERIFICAR: Se algum √≠ndice == -1 ‚Üí destruir grafo e retornar NULL

5. EXECUTAR DIJKSTRA:
   - int* distancias = NULL
   - int* anteriores = NULL
   - executar_dijkstra(grafo, idx_origem, &distancias, &anteriores)
   - ‚ö†Ô∏è VERIFICAR: Se retornar 0 (falha) ‚Üí destruir grafo e retornar NULL

6. RECONSTRUIR CAMINHO:
   - ResultadoRota* resultado = reconstruir_caminho(grafo, distancias, anteriores, 
                                                   idx_origem, idx_destino)

7. LIMPEZA:
   - Liberar distancias
   - Liberar anteriores
   - Destruir grafo (destruir_grafo(grafo))

8. RETORNAR RESULTADO:
   - Retornar resultado (pode ser NULL se caminho n√£o encontrado)
   - ‚ö†Ô∏è IMPORTANTE: resultado cont√©m IDs, n√£o coordenadas
```

#### **Fun√ß√£o 5: `liberar_resultado()` (EXPORTADA)**
```c
EXPORT void liberar_resultado(ResultadoRota* resultado)
```
**Prop√≥sito:** Liberar mem√≥ria alocada para ResultadoRota.
**Fluxo:**
```
Se resultado != NULL:
   - Liberar resultado->sequencia_ids
   - Liberar resultado
‚ö†Ô∏è IMPORTANTE: Sempre chamar ap√≥s usar ResultadoRota para evitar vazamento de mem√≥ria
```

#### **Fun√ß√£o 6: `obter_info_vertice()` (EXPORTADA - PARA LISTA)**
```c
EXPORT int obter_info_vertice(int id, char* nome_out, int nome_len, 
                             char* categoria_out, int cat_len,
                             int* x_out, int* y_out)
```
**Prop√≥sito:** Obter informa√ß√µes de um v√©rtice para mostrar na LISTA do frontend. Retorna dados do **BANCO 1**.
**Fluxo:**
```
1. Acessar dados est√°ticos do BANCO 1:
   - int count;
   - const VerticeData* vertices = obter_vertices_static(&count);

2. BUSCAR V√âRTICE POR ID:
   - Para i de 0 at√© count-1:
     Se vertices[i].id == id:
       // ENCONTRADO

3. COPIAR INFORMA√á√ïES (COM SEGURAN√áA):
   - Se nome_out != NULL:
     strncpy(nome_out, vertices[i].nome, nome_len - 1)
     nome_out[nome_len - 1] = '\0'
   
   - Se categoria_out != NULL:
     strncpy(categoria_out, vertices[i].categoria, cat_len - 1)
     categoria_out[cat_len - 1] = '\0'
   
   - Se x_out != NULL: *x_out = vertices[i].x  // Coordenada DA CAL√áADA
   - Se y_out != NULL: *y_out = vertices[i].y  // Coordenada DA CAL√áADA
   
   - Retornar 0 (sucesso)

4. SE N√ÉO ENCONTRADO:
   - Retornar -1
```

#### **Fun√ß√£o 7: `obter_numero_total_vertices()` (EXPORTADA - PARA LISTA)**
```c
EXPORT int obter_numero_total_vertices()
```
**Prop√≥sito:** Informar quantos pontos est√£o dispon√≠veis para a LISTA do frontend.
**Fluxo:**
```
1. Acessar dados est√°ticos do BANCO 1:
   - int count;
   - const VerticeData* vertices = obter_vertices_static(&count);

2. RETORNAR:
   - Retornar count
```

### **üõ†Ô∏è COMPILA√á√ÉO:**

**`COMPILE.BAT` - MODIFICAR:**
```batch
# ADICIONAR:
echo [4/6] grafo_algoritmos.c
gcc -std=c99 -c grafo_algoritmos.c -o grafo_algoritmos.o || goto erro

# ATUALIZAR linha da DLL:
gcc -shared -o router.dll main.o grafo.o grafo_data.o grafo_db.o grafo_algoritmos.o || goto erro
```

---

## ‚ö†Ô∏è **ALERTAS E BOAS PR√ÅTICAS (BACKEND):**

### **ERROS COMUNS A EVITAR:**
1. **Vazamento de mem√≥ria:** Sempre liberar arrays alocados (distancias, anteriores, sequencia_ids)
2. **Acesso fora dos limites:** Verificar √≠ndices antes de acessar arrays
3. **Loops infinitos:** Proteger reconstru√ß√£o do caminho (num_ids ‚â§ num_vertices)
4. **Ponteiros nulos:** Verificar NULL antes de dereferenciar
5. **Overflow de buffer:** Usar `strncpy` com limite e terminador '\0'
6. **IDs inv√°lidos:** Validar se origem/destino existem no BANCO 1
7. **Rota trivial:** Verificar se origem != destino

### **OTIMIZA√á√ïES FUTURAS:**
1. **Singleton do grafo:** Em produ√ß√£o, manter grafo carregado em mem√≥ria
2. **Cache de √≠ndices:** Hash table para ID‚Üí√≠ndice O(1) em vez de O(n)
3. **Early exit:** Parar Dijkstra se destino for alcan√ßado antes

### **VALIDA√á√ïES ESSENCIAIS:**
1. **IDs existem:** Verificar se origem e destino existem no BANCO 1
2. **Destino alcan√ß√°vel:** Verificar se h√° caminho entre os pontos
3. **Par√¢metros v√°lidos:** IDs ‚â• 0
4. **Mem√≥ria dispon√≠vel:** Verificar sucesso de aloca√ß√µes
5. **Rota n√£o trivial:** origem != destino

---

## üîÑ **FLUXO DE DADOS COMPLETO:**

### **1. Frontend carrega LISTA:**
```
Chama: obter_numero_total_vertices() ‚Üí 120 pontos
Para cada ID de 0 a 119:
  Chama: obter_info_vertice(id, ...) ‚Üí nome, categoria, coordenadas
  Exibe na lista: "Pastelaria Pasteten Platz (Restaurante)"
```

### **2. Usu√°rio seleciona:**
```
Origem: ID 22 (Pastelaria)
Destino: ID 114 (McDonald's)
```

### **3. Frontend calcula rota:**
```
Chama: calcular_rota(22, 114)
Recebe: ResultadoRota* com:
  - sequencia_ids: [22, 23, 24, 25, 3, 105, 106, ..., 114]
  - num_ids: 17
  - distancia_total: 450
```

### **4. Frontend processa resultado:**
```
Para cada ID na sequ√™ncia:
  Chama: obter_info_vertice(id, ..., &x, &y)
  Obt√©m: coordenadas DA CAL√áADA do BANCO 1
  Desenha: linha conectando pontos no mapa
```

---

## üéØ **PR√ìXIMOS PASSOS IMEDIATOS:**

### **FASE 1: IMPLEMENTAR BACKEND**
1. Criar `grafo_algoritmos.h` com 4 prot√≥tipos
2. Implementar `grafo_algoritmos.c` com 7 fun√ß√µes
3. Atualizar `main.c` com exporta√ß√µes
4. Atualizar `grafo.h` com ResultadoRota simplificada
5. Atualizar `COMPILE.BAT`
6. Compilar e testar

### **FASE 2: TESTES**
1. Testar rota conhecida (ID 22 ‚Üí ID 114)
2. Testar rota inv√°lida (IDs inexistentes)
3. Testar rota trivial (origem = destino)
4. Testar vazamento de mem√≥ria
5. Testar performance com m√∫ltiplas chamadas

**Este prompt cobre 100% do backend para sistema de lista com Dijkstra.** üöÄ


