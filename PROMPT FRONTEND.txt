# üé® **MEGA PROMPT DETALHADO - FRONTEND PARA SISTEMA DIJKSTRA**

## üéØ **OBJETIVO GERAL:**
Implementar frontend em Python que:
1. Permita selecionar origem/destino via LISTA
2. Chame backend C para calcular rota Dijkstra
3. Desenhe rota no mapa usando coordenadas dos V√âRTICES (cal√ßadas)
4. Tenha sistema de limpeza e valida√ß√£o

---

## üîß **PARTE 1: ESTRUTURA DO FRONTEND**

### **üìÅ ESTRUTURA DE ARQUIVOS:**

#### **Arquivos Principais:**
- `app.py` - Aplica√ß√£o principal (substituir existente)
- `navegacao.py` - Interface com backend C (modificar existente)
- `mapa.py` - Gerenciamento do mapa e desenho (novo ou modificar)
- `interface.py` - Componentes de UI (novo ou modificar)

---

## üß† **PARTE 2: IMPLEMENTA√á√ÉO DETALHADA**

### **2.1 `navegacao.py` - COMUNICA√á√ÉO COM BACKEND C**

#### **Estrutura necess√°ria:**
```python
import ctypes
from ctypes import *
from typing import Optional, Dict, Tuple, List

# ============================================
# üÜï ESTRUTURA C: ResultadoRota
# ============================================
class ResultadoRota(Structure):
    _fields_ = [
        ("sequencia_ids", POINTER(c_int)),  # Array de IDs do caminho
        ("num_ids", c_int),                  # Quantidade de IDs
        ("distancia_total", c_int)           # Dist√¢ncia em metros
    ]

# ============================================
# üÜï CLASSE: RouterLib (Wrapper da DLL)
# ============================================
class RouterLib:
    def __init__(self):
        self.lib = None
        self._load_and_configure_lib()
    
    def _load_and_configure_lib(self):
        """Carrega DLL e configura TODAS as fun√ß√µes C"""
        try:
            # 1. CARREGAR DLL
            dll_path = os.path.join('backend', 'router.dll')
            if not os.path.exists(dll_path):
                raise FileNotFoundError(f"DLL n√£o encontrada: {dll_path}")
            
            self.lib = cdll.LoadLibrary(dll_path)
            print("‚úÖ DLL carregada com sucesso")
            
            # 2. CONFIGURAR FUN√á√ïES EXISTENTES
            self.lib.get_test_message.argtypes = []
            self.lib.get_test_message.restype = c_char_p
            
            self.lib.get_num_pontos.argtypes = []
            self.lib.get_num_pontos.restype = c_int
            
            self.lib.get_ponto_info.argtypes = [
                c_int, c_char_p, c_int, c_char_p, c_int,
                POINTER(c_int), POINTER(c_int), POINTER(c_int)
            ]
            self.lib.get_ponto_info.restype = c_int
            
            # 3. üÜï CONFIGURAR NOVAS FUN√á√ïES DO DIJKSTRA
            # Fun√ß√£o principal
            self.lib.calcular_rota.argtypes = [c_int, c_int]
            self.lib.calcular_rota.restype = POINTER(ResultadoRota)
            
            # Liberar resultado
            self.lib.liberar_resultado.argtypes = [POINTER(ResultadoRota)]
            self.lib.liberar_resultado.restype = None
            
            # Fun√ß√µes para lista
            self.lib.obter_numero_total_vertices.argtypes = []
            self.lib.obter_numero_total_vertices.restype = c_int
            
            self.lib.obter_info_vertice.argtypes = [
                c_int, c_char_p, c_int, c_char_p, c_int,
                POINTER(c_int), POINTER(c_int)
            ]
            self.lib.obter_info_vertice.restype = c_int
            
            print("‚úÖ Todas as fun√ß√µes C configuradas")
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar DLL: {e}")
            self.lib = None
```

#### **Fun√ß√£o 1: `carregar_lista_pontos()`**
```python
def carregar_lista_pontos(self) -> List[Dict]:
    """
    Carrega TODOS os pontos do BANCO 1 para a lista do frontend.
    Usa coordenadas dos V√âRTICES (cal√ßadas) para Dijkstra.
    """
    if not self.lib:
        return []
    
    pontos = []
    try:
        # 1. Obter n√∫mero total de v√©rtices
        num_vertices = self.lib.obter_numero_total_vertices()
        
        # 2. Para cada v√©rtice, obter informa√ß√µes
        for id_vertice in range(num_vertices):
            # Buffers para informa√ß√µes
            nome_buf = create_string_buffer(100)
            categoria_buf = create_string_buffer(50)
            x = c_int()
            y = c_int()
            
            # 3. Chamar fun√ß√£o C para obter informa√ß√µes
            resultado = self.lib.obter_info_vertice(
                id_vertice,
                nome_buf, 100,        # Nome com limite de 100 chars
                categoria_buf, 50,    # Categoria com limite de 50 chars
                byref(x),            # Coordenada X (cal√ßada)
                byref(y)             # Coordenada Y (cal√ßada)
            )
            
            # 4. Se sucesso, adicionar √† lista
            if resultado == 0:
                ponto = {
                    'id': id_vertice,
                    'nome': nome_buf.value.decode('utf-8', errors='ignore'),
                    'categoria': categoria_buf.value.decode('utf-8', errors='ignore'),
                    'x_vertice': x.value,    # ‚úÖ Coordenada do V√âRTICE (cal√ßada)
                    'y_vertice': y.value,    # ‚úÖ Para Dijkstra e desenho da rota
                    'x_visual': x.value,     # ‚è≥ Futuro: coordenada visual (BANCO 2)
                    'y_visual': y.value      # ‚è≥ Futuro: coordenada visual (BANCO 2)
                }
                pontos.append(ponto)
        
        print(f"‚úÖ {len(pontos)} pontos carregados do BANCO 1")
        return pontos
        
    except Exception as e:
        print(f"‚ùå Erro ao carregar lista de pontos: {e}")
        return []
```

#### **Fun√ß√£o 2: `calcular_rota()`**
```python
def calcular_rota(self, id_origem: int, id_destino: int) -> Optional[Dict]:
    """
    Calcula rota usando Dijkstra no backend C.
    Retorna dicion√°rio com sequ√™ncia de IDs e dist√¢ncia.
    """
    if not self.lib:
        print("‚ùå Biblioteca C n√£o carregada")
        return None
    
    # ‚ö†Ô∏è VALIDA√á√ÉO: origem != destino
    if id_origem == id_destino:
        print("‚ùå Origem e destino s√£o iguais")
        return None
    
    try:
        print(f"üîÑ Calculando rota Dijkstra: {id_origem} ‚Üí {id_destino}")
        
        # 1. CHAMAR FUN√á√ÉO C PRINCIPAL
        resultado_ptr = self.lib.calcular_rota(id_origem, id_destino)
        
        # 2. VERIFICAR SE FOI POSS√çVEL CALCULAR
        if not resultado_ptr:
            print("‚ùå N√£o foi poss√≠vel calcular a rota (retornou NULL)")
            return None
        
        # 3. EXTRAIR RESULTADO
        resultado = resultado_ptr.contents
        
        # 4. CONVERTER PARA DICION√ÅRIO PYTHON
        rota_dict = {
            'sequencia_ids': [],
            'num_ids': resultado.num_ids,
            'distancia_total': resultado.distancia_total
        }
        
        # 5. EXTRAIR SEQU√äNCIA DE IDs
        for i in range(resultado.num_ids):
            rota_dict['sequencia_ids'].append(resultado.sequencia_ids[i])
        
        print(f"‚úÖ Rota calculada: {rota_dict['num_ids']} pontos, "
              f"{rota_dict['distancia_total']} metros")
        
        # 6. LIBERAR MEM√ìRIA C
        self.lib.liberar_resultado(resultado_ptr)
        
        return rota_dict
        
    except Exception as e:
        print(f"‚ùå Erro ao calcular rota: {e}")
        return None
```

#### **Fun√ß√£o 3: `obter_coordenadas_vertice()`**
```python
def obter_coordenadas_vertice(self, id_vertice: int) -> Optional[Tuple[int, int]]:
    """
    Obt√©m coordenadas do V√âRTICE (cal√ßada) para um ID espec√≠fico.
    Usado para desenhar a rota no mapa.
    """
    if not self.lib:
        return None
    
    try:
        x = c_int()
        y = c_int()
        
        # ‚ö†Ô∏è IMPORTANTE: Usa obter_info_vertice que retorna coordenadas do V√âRTICE
        resultado = self.lib.obter_info_vertice(
            id_vertice,
            None, 0,   # N√£o precisa do nome
            None, 0,   # N√£o precisa da categoria
            byref(x),  # Coordenada X do v√©rtice
            byref(y)   # Coordenada Y do v√©rtice
        )
        
        if resultado == 0:
            return (x.value, y.value)
        else:
            print(f"‚ö†Ô∏è V√©rtice {id_vertice} n√£o encontrado")
            return None
            
    except Exception as e:
        print(f"‚ùå Erro ao obter coordenadas: {e}")
        return None
```

---

### **2.2 `app.py` - APLICA√á√ÉO PRINCIPAL**

#### **Classe Principal:**
```python
class DijkstraApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Sistema de Navega√ß√£o - Dijkstra")
        self.root.geometry("1400x800")
        
        # ============================================
        # üèóÔ∏è COMPONENTES PRINCIPAIS
        # ============================================
        
        # 1. BACKEND
        self.router = RouterLib()
        
        # 2. ESTADO DA APLICA√á√ÉO
        self.pontos_lista: List[Dict] = []      # Todos os pontos do BANCO 1
        self.origem_id: Optional[int] = None    # ID da origem selecionada
        self.destino_id: Optional[int] = None   # ID do destino selecionado
        self.rota_atual: Optional[Dict] = None  # Rota calculada atual
        
        # 3. ELEMENTOS VISUAIS
        self.marcadores_origem = []      # Marcadores no mapa
        self.marcadores_destino = []
        self.linhas_rota = []            # Linhas da rota desenhada
        
        # 4. INTERFACE
        self._criar_interface()
        self._carregar_dados_iniciais()
```

#### **Fun√ß√£o: `_criar_interface()`**
```python
def _criar_interface(self):
    """Cria toda a interface gr√°fica"""
    
    # ============================================
    # üé® LAYOUT PRINCIPAL
    # ============================================
    
    # Frame esquerdo: Controles (400px)
    self.frame_controles = ttk.Frame(self.root, width=400)
    self.frame_controles.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)
    self.frame_controles.pack_propagate(False)
    
    # Frame direito: Mapa (expande)
    self.frame_mapa = ttk.Frame(self.root)
    self.frame_mapa.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    # ============================================
    # üìã SE√á√ÉO 1: LISTA DE PONTOS
    # ============================================
    
    frame_lista = ttk.LabelFrame(self.frame_controles, text="üìã Lista de Pontos", padding=10)
    frame_lista.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
    
    # Barra de pesquisa
    ttk.Label(frame_lista, text="Pesquisar:").pack(anchor=tk.W)
    self.entry_pesquisa = ttk.Entry(frame_lista)
    self.entry_pesquisa.pack(fill=tk.X, pady=(0, 5))
    self.entry_pesquisa.bind('<KeyRelease>', self._filtrar_lista)
    
    # Lista de pontos (Treeview)
    colunas = ('ID', 'Nome', 'Categoria')
    self.tree_pontos = ttk.Treeview(frame_lista, columns=colunas, show='headings', height=15)
    
    # Configurar colunas
    self.tree_pontos.heading('ID', text='ID')
    self.tree_pontos.heading('Nome', text='Nome')
    self.tree_pontos.heading('Categoria', text='Categoria')
    
    self.tree_pontos.column('ID', width=50)
    self.tree_pontos.column('Nome', width=200)
    self.tree_pontos.column('Categoria', width=100)
    
    # Scrollbar
    scrollbar = ttk.Scrollbar(frame_lista, orient=tk.VERTICAL, command=self.tree_pontos.yview)
    self.tree_pontos.configure(yscrollcommand=scrollbar.set)
    
    self.tree_pontos.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    # Bind duplo clique para sele√ß√£o
    self.tree_pontos.bind('<Double-1>', self._on_ponto_selecionado)
    
    # ============================================
    # üéØ SE√á√ÉO 2: SELE√á√ÉO ORIGEM/DESTINO
    # ============================================
    
    frame_selecao = ttk.LabelFrame(self.frame_controles, text="üéØ Sele√ß√£o", padding=10)
    frame_selecao.pack(fill=tk.X, pady=(0, 10))
    
    # Origem
    frame_origem = ttk.Frame(frame_selecao)
    frame_origem.pack(fill=tk.X, pady=(0, 5))
    
    ttk.Label(frame_origem, text="Origem:", width=10).pack(side=tk.LEFT)
    self.label_origem = ttk.Label(frame_origem, text="N√£o selecionada", foreground="blue")
    self.label_origem.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    # Destino
    frame_destino = ttk.Frame(frame_selecao)
    frame_destino.pack(fill=tk.X, pady=(0, 10))
    
    ttk.Label(frame_destino, text="Destino:", width=10).pack(side=tk.LEFT)
    self.label_destino = ttk.Label(frame_destino, text="N√£o selecionado", foreground="red")
    self.label_destino.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    # ============================================
    # üöÄ SE√á√ÉO 3: BOT√ïES DE A√á√ÉO
    # ============================================
    
    frame_botoes = ttk.Frame(self.frame_controles)
    frame_botoes.pack(fill=tk.X, pady=(0, 10))
    
    # Bot√£o Calcular Rota (inicialmente desabilitado)
    self.btn_calcular = ttk.Button(
        frame_botoes, 
        text="üöÄ Calcular Rota", 
        command=self._calcular_rota,
        state=tk.DISABLED
    )
    self.btn_calcular.pack(fill=tk.X, pady=(0, 5))
    
    # Bot√£o Limpar Rota (inicialmente desabilitado)
    self.btn_limpar = ttk.Button(
        frame_botoes, 
        text="üóëÔ∏è Limpar Rota", 
        command=self._limpar_rota,
        state=tk.DISABLED
    )
    self.btn_limpar.pack(fill=tk.X)
    
    # ============================================
    # üìä SE√á√ÉO 4: RESULTADOS
    # ============================================
    
    frame_resultados = ttk.LabelFrame(self.frame_controles, text="üìä Resultados", padding=10)
    frame_resultados.pack(fill=tk.BOTH, expand=True)
    
    # √Årea de texto para resultados
    self.text_resultados = tk.Text(frame_resultados, height=8, wrap=tk.WORD)
    scrollbar_resultados = ttk.Scrollbar(frame_resultados, command=self.text_resultados.yview)
    self.text_resultados.configure(yscrollcommand=scrollbar_resultados.set)
    
    self.text_resultados.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar_resultados.pack(side=tk.RIGHT, fill=tk.Y)
    
    # ============================================
    # üó∫Ô∏è SE√á√ÉO 5: MAPA
    # ============================================
    
    # Canvas para o mapa (imagem de fundo)
    self.canvas_mapa = tk.Canvas(self.frame_mapa, bg="white", cursor="crosshair")
    self.canvas_mapa.pack(fill=tk.BOTH, expand=True)
    
    # Carregar imagem do mapa (se existir)
    self._carregar_imagem_mapa()
```

#### **Fun√ß√£o: `_carregar_dados_iniciais()`**
```python
def _carregar_dados_iniciais(self):
    """Carrega dados iniciais da aplica√ß√£o"""
    
    # 1. TESTAR BACKEND
    self._log("üîå Testando conex√£o com backend C...")
    mensagem = self.router.lib.get_test_message().decode('utf-8') if self.router.lib else "‚ùå Falha"
    self._log(f"Backend: {mensagem}")
    
    # 2. CARREGAR LISTA DE PONTOS DO BANCO 1
    self._log("üìã Carregando lista de pontos...")
    self.pontos_lista = self.router.carregar_lista_pontos()
    
    # 3. PREENCHER TREEVIEW
    for ponto in self.pontos_lista:
        self.tree_pontos.insert('', tk.END, values=(
            ponto['id'],
            ponto['nome'],
            ponto['categoria']
        ))
    
    self._log(f"‚úÖ {len(self.pontos_lista)} pontos carregados")
```

#### **Fun√ß√£o: `_on_ponto_selecionado()`**
```python
def _on_ponto_selecionado(self, event):
    """Quando usu√°rio seleciona um ponto da lista"""
    
    # 1. OBTER ITEM SELECIONADO
    item = self.tree_pontos.selection()
    if not item:
        return
    
    # 2. OBTER DADOS DO ITEM
    item_data = self.tree_pontos.item(item[0])
    valores = item_data['values']
    
    if len(valores) < 3:
        return
    
    id_ponto = valores[0]
    nome_ponto = valores[1]
    
    # 3. PERGUNTAR: ORIGEM OU DESTINO?
    resposta = messagebox.askquestion(
        "Sele√ß√£o de Ponto",
        f"Selecionar '{nome_ponto}' (ID: {id_ponto}) como:\n\n"
        "Sim ‚Üí Origem\nN√£o ‚Üí Destino",
        icon='question'
    )
    
    # 4. DEFINIR ORIGEM OU DESTINO
    if resposta == 'yes':
        self._definir_origem(id_ponto, nome_ponto)
    else:
        self._definir_destino(id_ponto, nome_ponto)
```

#### **Fun√ß√£o: `_definir_origem()`**
```python
def _definir_origem(self, id_ponto: int, nome_ponto: str):
    """Define ponto como origem"""
    
    # ‚ö†Ô∏è VALIDA√á√ÉO: n√£o pode ser mesmo ponto que destino
    if self.destino_id == id_ponto:
        messagebox.showwarning("Aviso", "Origem n√£o pode ser igual ao destino!")
        return
    
    # 1. ATUALIZAR ESTADO
    self.origem_id = id_ponto
    
    # 2. ATUALIZAR INTERFACE
    self.label_origem.config(text=f"{nome_ponto} (ID: {id_ponto})")
    
    # 3. OBTER COORDENADAS DO V√âRTICE
    coords = self.router.obter_coordenadas_vertice(id_ponto)
    if coords:
        x, y = coords
        self._desenhar_marcador(x, y, "blue", "Origem", self.marcadores_origem)
    
    # 4. ATUALIZAR BOT√ïES
    self._atualizar_estado_botoes()
    
    # 5. LOG
    self._log(f"üìç Origem definida: {nome_ponto} (ID: {id_ponto})")
```

#### **Fun√ß√£o: `_definir_destino()`**
```python
def _definir_destino(self, id_ponto: int, nome_ponto: str):
    """Define ponto como destino"""
    
    # ‚ö†Ô∏è VALIDA√á√ÉO: n√£o pode ser mesmo ponto que origem
    if self.origem_id == id_ponto:
        messagebox.showwarning("Aviso", "Destino n√£o pode ser igual √† origem!")
        return
    
    # 1. ATUALIZAR ESTADO
    self.destino_id = id_ponto
    
    # 2. ATUALIZAR INTERFACE
    self.label_destino.config(text=f"{nome_ponto} (ID: {id_ponto})")
    
    # 3. OBTER COORDENADAS DO V√âRTICE
    coords = self.router.obter_coordenadas_vertice(id_ponto)
    if coords:
        x, y = coords
        self._desenhar_marcador(x, y, "red", "Destino", self.marcadores_destino)
    
    # 4. ATUALIZAR BOT√ïES
    self._atualizar_estado_botoes()
    
    # 5. LOG
    self._log(f"üéØ Destino definido: {nome_ponto} (ID: {id_ponto})")
```

#### **Fun√ß√£o: `_calcular_rota()`**
```python
def _calcular_rota(self):
    """Calcula rota usando Dijkstra"""
    
    # ‚ö†Ô∏è VALIDA√á√ÉO FINAL
    if self.origem_id is None or self.destino_id is None:
        messagebox.showwarning("Aviso", "Selecione origem e destino primeiro!")
        return
    
    if self.origem_id == self.destino_id:
        messagebox.showwarning("Aviso", "Origem e destino n√£o podem ser iguais!")
        return
    
    # ‚ö†Ô∏è VERIFICAR SE J√Å EXISTE ROTA
    if self.rota_atual is not None:
        resposta = messagebox.askyesno(
            "Rota Existente",
            "J√° existe uma rota calculada. Deseja substitu√≠-la?"
        )
        if not resposta:
            return
        self._limpar_rota()
    
    # 1. MOSTRAR LOADING
    self._log(f"üîÑ Calculando rota: ID {self.origem_id} ‚Üí ID {self.destino_id}")
    self.btn_calcular.config(state=tk.DISABLED)
    self.root.update()
    
    try:
        # 2. CHAMAR BACKEND C
        resultado = self.router.calcular_rota(self.origem_id, self.destino_id)
        
        if not resultado:
            self._log("‚ùå N√£o foi poss√≠vel calcular a rota")
            messagebox.showerror("Erro", "N√£o foi poss√≠vel calcular a rota")
            return
        
        # 3. ARMAZENAR ROTA
        self.rota_atual = resultado
        
        # 4. PROCESSAR RESULTADO
        self._processar_resultado_rota(resultado)
        
        # 5. HABILITAR BOT√ÉO LIMPAR
        self.btn_limpar.config(state=tk.NORMAL)
        
    except Exception as e:
        self._log(f"‚ùå Erro: {e}")
        messagebox.showerror("Erro", f"Erro ao calcular rota: {e}")
        
    finally:
        # 6. RESTAURAR BOT√ÉO
        self.btn_calcular.config(state=tk.NORMAL)
```

#### **Fun√ß√£o: `_processar_resultado_rota()`**
```python
def _processar_resultado_rota(self, resultado: Dict):
    """Processa resultado da rota e desenha no mapa"""
    
    try:
        sequencia_ids = resultado['sequencia_ids']
        distancia_total = resultado['distancia_total']
        num_pontos = resultado['num_ids']
        
        # 1. MOSTRAR INFORMA√á√ïES
        self._log("‚úÖ Rota calculada com sucesso!")
        self._log(f"üìè Dist√¢ncia total: {distancia_total} metros")
        self._log(f"üìç N√∫mero de pontos no caminho: {num_pontos}")
        self._log(f"üõ£Ô∏è  Sequ√™ncia de IDs: {' ‚Üí '.join(map(str, sequencia_ids))}")
        
        # 2. CONVERTER IDs ‚Üí COORDENADAS DE V√âRTICES
        coordenadas = []
        for id_vertice in sequencia_ids:
            coords = self.router.obter_coordenadas_vertice(id_vertice)
            if coords:
                coordenadas.append(coords)
            else:
                self._log(f"‚ö†Ô∏è V√©rtice {id_vertice} n√£o encontrado (pulando)")
        
        # 3. VERIFICAR SE TEM COORDENADAS SUFICIENTES
        if len(coordenadas) < 2:
            self._log("‚ùå Coordenadas insuficientes para desenhar rota")
            return
        
        # 4. DESENHAR ROTA NO MAPA
        self._desenhar_rota_mapa(coordenadas)
        
        self._log(f"üé® Rota desenhada no mapa ({len(coordenadas)} pontos)")
        
    except Exception as e:
        self._log(f"‚ùå Erro ao processar rota: {e}")
```

#### **Fun√ß√£o: `_desenhar_rota_mapa()`**
```python
def _desenhar_rota_mapa(self, coordenadas: List[Tuple[int, int]]):
    """
    Desenha rota no mapa conectando as coordenadas dos V√âRTICES.
    Usa coordenadas do BANCO 1 (cal√ßadas).
    """
    
    # LIMPAR ROTA ANTERIOR
    for linha in self.linhas_rota:
        self.canvas_mapa.delete(linha)
    self.linhas_rota.clear()
    
    # DESENHAR NOVAS LINHAS
    for i in range(len(coordenadas) - 1):
        x1, y1 = coordenadas[i]
        x2, y2 = coordenadas[i + 1]
        
        # ‚ö†Ô∏è IMPORTANTE: Escalar coordenadas se necess√°rio
        # (depende da imagem do mapa)
        x1_scaled, y1_scaled = self._escalar_coordenadas(x1, y1)
        x2_scaled, y2_scaled = self._escalar_coordenadas(x2, y2)
        
        # Desenhar linha
        linha = self.canvas_mapa.create_line(
            x1_scaled, y1_scaled, x2_scaled, y2_scaled,
            fill="#4361ee",        # Cor azul
            width=3,               # Espessura
            arrow=tk.LAST,         # Seta no final
            dash=(5, 2) if i < len(coordenadas) - 2 else (),  # Tracejado exceto √∫ltimo
            tags="rota"
        )
        self.linhas_rota.append(linha)
```

#### **Fun√ß√£o: `_limpar_rota()`**
```python
def _limpar_rota(self):
    """Limpa rota atual do mapa"""
    
    # 1. LIMPAR MARCADORES DA ROTA
    for linha in self.linhas_rota:
        self.canvas_mapa.delete(linha)
    self.linhas_rota.clear()
    
    # 2. LIMPAR MARCADORES ORIGEM/DESTINO
    for marcador in self.marcadores_origem:
        self.canvas_mapa.delete(marcador)
    self.marcadores_origem.clear()
    
    for marcador in self.marcadores_destino:
        self.canvas_mapa.delete(marcador)
    self.marcadores_destino.clear()
    
    # 3. RESETAR ESTADO
    self.origem_id = None
    self.destino_id = None
    self.rota_atual = None
    
    # 4. ATUALIZAR INTERFACE
    self.label_origem.config(text="N√£o selecionada")
    self.label_destino.config(text="N√£o selecionado")
    self._atualizar_estado_botoes()
    
    # 5. LOG
    self._log("üóëÔ∏è Rota limpa")
```

#### **Fun√ß√£o: `_atualizar_estado_botoes()`**
```python
def _atualizar_estado_botoes(self):
    """Atualiza estado dos bot√µes baseado no estado atual"""
    
    # Bot√£o Calcular: habilitado se origem E destino selecionados
    if self.origem_id is not None and self.destino_id is not None:
        self.btn_calcular.config(state=tk.NORMAL)
    else:
        self.btn_calcular.config(state=tk.DISABLED)
    
    # Bot√£o Limpar: habilitado se h√° rota calculada
    if self.rota_atual is not None:
        self.btn_limpar.config(state=tk.NORMAL)
    else:
        self.btn_limpar.config(state=tk.DISABLED)
```

---

## ‚ö†Ô∏è **ALERTAS E BOAS PR√ÅTICAS (FRONTEND):**

### **ERROS COMUNS A EVITAR:**
1. **IDs inv√°lidos:** Validar se IDs existem antes de enviar para backend
2. **Origem = Destino:** Bloquear c√°lculo se pontos forem iguais
3. **Rota sobreposta:** N√£o permitir nova rota sem limpar anterior
4. **Thread bloqueante:** Dijkstra pode demorar - usar thread separada em produ√ß√£o
5. **Coordenadas fora do mapa:** Escalar coordenadas para imagem do mapa

### **VALIDA√á√ïES ESSENCIAIS:**
1. **Backend carregado:** Verificar DLL antes de qualquer opera√ß√£o
2. **Sele√ß√£o completa:** Origem E destino devem estar selecionados
3. **Rota existente:** Perguntar antes de substituir rota atual
4. **IDs v√°lidos:** Verificar se IDs existem no BANCO 1

### **MELHORIAS FUTURAS:**
1. **Thread separada:** Executar Dijkstra em thread para n√£o travar UI
2. **Progresso:** Barra de progresso durante c√°lculo
3. **Cache de coordenadas:** Evitar chamadas repetidas ao C
4. **Zoom/pan:** Navega√ß√£o no mapa
5. **Banco 2:** Integra√ß√£o com coordenadas visuais

---

## üîÑ **FLUXO COMPLETO DO USU√ÅRIO:**

```
1. INICIAR APLICA√á√ÉO
   ‚Üí Carrega DLL do backend
   ‚Üí Carrega lista de pontos do BANCO 1
   ‚Üí Exibe lista na interface

2. SELECIONAR ORIGEM
   ‚Üí Clica 2x em ponto da lista
   ‚Üí Escolhe "Origem"
   ‚Üí Mostra marcador no mapa (coordenada do v√©rtice)

3. SELECIONAR DESTINO
   ‚Üí Clica 2x em outro ponto
   ‚Üí Escolhe "Destino"
   ‚Üí Mostra marcador no mapa

4. CALCULAR ROTA
   ‚Üí Clica "Calcular Rota"
   ‚Üí Chama backend C com IDs
   ‚Üí Recebe sequ√™ncia de IDs
   ‚Üí Converte IDs em coordenadas de v√©rtices
   ‚Üí Desenha linhas conectando pontos

5. VISUALIZAR RESULTADO
   ‚Üí Mostra dist√¢ncia total
   ‚Üí Mostra n√∫mero de pontos
   ‚Üí Rota destacada no mapa

6. LIMPAR ROTA (opcional)
   ‚Üí Clica "Limpar Rota"
   ‚Üí Remove tudo do mapa
   ‚Üí Permite nova sele√ß√£o
```

---

## üéØ **PR√ìXIMOS PASSOS:**

### **FASE 1: IMPLEMENTA√á√ÉO B√ÅSICA**
1. Criar `navegacao.py` com wrapper C
2. Implementar `app.py` com interface principal
3. Testar comunica√ß√£o backend-frontend
4. Testar c√°lculo de rota simples

### **FASE 2: REFINAMENTOS**
1. Adicionar imagem de mapa real
2. Implementar escalonamento de coordenadas
3. Adicionar valida√ß√µes avan√ßadas
4. Melhorar tratamento de erros

### **FASE 3: OTIMIZA√á√ïES**
1. Thread separada para Dijkstra
2. Cache de coordenadas
3. Banco 2 para coordenadas visuais
4. Zoom/pan no mapa

**Este prompt cobre 100% do frontend para sistema Dijkstra com sele√ß√£o por lista.** üöÄ